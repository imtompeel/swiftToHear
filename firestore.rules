rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // Allow anyone to create email signups (for the signup form)
    match /emailSignups/{document} {
      allow create: if 
        request.resource.data.email is string &&
        request.resource.data.email.size() > 0;
      // Only allow superadmins to read email signups
      allow read, update, delete: if 
        request.auth != null && 
        exists(/databases/$(database)/documents/superadmins/$(request.auth.uid));
    }
    
    // Superadmin collection - allow initial setup and then restrict to superadmins
    match /superadmins/{document} {
      // For the first superadmin setup, allow authenticated users to create their own document
      // Once a superadmin exists, only superadmins can read/write
      allow read, write: if 
        request.auth != null && 
        (document == request.auth.uid || 
         exists(/databases/$(database)/documents/superadmins/$(request.auth.uid)));
    }
    
    // Test collection (for debugging)
    match /test/{document} {
      allow read, write: if request.auth != null;
    }
    
    // Session management rules
    match /sessions/{sessionId} {
      // Allow authenticated users to create sessions
      allow create: if 
        request.auth != null &&
        request.auth.uid == request.resource.data.hostId &&
        request.resource.data.sessionId == sessionId &&
        request.resource.data.status == 'waiting';
      
      // Allow anyone to read sessions (for anonymous joining)
      allow read: if true;
      
      // Allow anyone to update sessions (for anonymous joining)
      allow update: if true;
      
      // Allow host to delete their own session
      allow delete: if 
        request.auth != null &&
        request.auth.uid == resource.data.hostId;
    }
    
    // Group session management rules
    match /groupSessions/{sessionId} {
      // Allow authenticated users to create group sessions
      allow create: if 
        request.auth != null &&
        request.auth.uid == request.resource.data.hostId &&
        request.resource.data.sessionId == sessionId &&
        request.resource.data.status == 'waiting';
      
      // Allow authenticated users to read group sessions
      allow read: if request.auth != null;
      
      // Allow authenticated users to update group sessions if they are a participant
      allow update: if request.auth != null;
      
      // Allow host to delete their own group session
      allow delete: if 
        request.auth != null &&
        request.auth.uid == resource.data.hostId;
    }
    
    // WebRTC signaling rules
    match /signaling/{messageId} {
      // Allow authenticated users to create signaling messages
      allow create: if 
        request.auth != null &&
        request.auth.uid == request.resource.data.from &&
        request.resource.data.sessionId is string &&
        request.resource.data.sessionId.size() > 0;
      
      // Allow authenticated users to read all signaling messages in their session
      allow read: if 
        request.auth != null &&
        resource.data.sessionId is string;
      
      // Allow users to delete their own messages
      allow delete: if 
        request.auth != null &&
        request.auth.uid == resource.data.from;
    }
    
    // Deny all other access by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
}